#!/opt/homebrew/bin/chez --program

;; @generated by Idris 0.8.0-acde1c926, Chez backend
(import (chezscheme))
(case (machine-type)
  [(i3fb ti3fb a6fb ta6fb) #f]
  [(i3le ti3le a6le ta6le tarm64le)
     (with-exception-handler (lambda(x) (load-shared-object "libc.so"))
        (lambda () (load-shared-object "libc.so.6")))]
  [(i3osx ti3osx a6osx ta6osx tarm64osx tppc32osx tppc64osx) (load-shared-object "libc.dylib")]
  [(i3nt ti3nt a6nt ta6nt) (load-shared-object "msvcrt.dll")]
  [else (load-shared-object "libc.so")])

(load-shared-object "libidris2_support.dylib")

(let ()
#!chezscheme

(define (blodwen-os)
  (case (machine-type)
    [(i3le ti3le a6le ta6le tarm64le) "unix"]  ; GNU/Linux
    [(i3ob ti3ob a6ob ta6ob tarm64ob) "unix"]  ; OpenBSD
    [(i3fb ti3fb a6fb ta6fb tarm64fb) "unix"]  ; FreeBSD
    [(i3nb ti3nb a6nb ta6nb tarm64nb) "unix"]  ; NetBSD
    [(i3osx ti3osx a6osx ta6osx tarm64osx tppc32osx tppc64osx) "darwin"]
    [(i3nt ti3nt a6nt ta6nt tarm64nt) "windows"]
    [else "unknown"]))

(define blodwen-lazy
  (lambda (f)
    (let ([evaluated #f] [res void])
      (lambda ()
        (if (not evaluated)
            (begin (set! evaluated #t)
                   (set! res (f))
                   (set! f void))
            (void))
        res))))

(define (blodwen-delay-lazy f)
  (weak-cons #!bwp f))

(define (blodwen-force-lazy e)
  (let ((exval (car e)))
    (if (bwp-object? exval)
      (let ((val ((cdr e))))
        (begin (set-car! e val) val))
      exval)))

(define (blodwen-toSignedInt x bits)
  (if (logbit? bits x)
      (logor x (ash -1 bits))
      (logand x (sub1 (ash 1 bits)))))

(define (blodwen-toUnsignedInt x bits)
  (logand x (sub1 (ash 1 bits))))

(define (blodwen-euclidDiv a b)
  (let ((q (quotient a b))
        (r (remainder a b)))
    (if (< r 0)
      (if (> b 0) (- q 1) (+ q 1))
      q)))

(define (blodwen-euclidMod a b)
  (let ((r (remainder a b)))
    (if (< r 0)
      (if (> b 0) (+ r b) (- r b))
      r)))

; flonum constants

(define (blodwen-calcFlonumUnitRoundoff)
  (let loop [(uro 1.0)]
    (if (fl= 1.0 (fl+ 1.0 uro))
      uro
      (loop (fl/ uro 2.0)))))

(define (blodwen-calcFlonumEpsilon)
  (fl* (blodwen-calcFlonumUnitRoundoff) 2.0))

(define (blodwen-flonumNaN)
  +nan.0)

(define (blodwen-flonumInf)
  +inf.0)

; Bits

(define bu+ (lambda (x y bits) (blodwen-toUnsignedInt (+ x y) bits)))
(define bu- (lambda (x y bits) (blodwen-toUnsignedInt (- x y) bits)))
(define bu* (lambda (x y bits) (blodwen-toUnsignedInt (* x y) bits)))
(define bu/ (lambda (x y bits) (blodwen-toUnsignedInt (quotient x y) bits)))

(define bs+ (lambda (x y bits) (blodwen-toSignedInt (+ x y) bits)))
(define bs- (lambda (x y bits) (blodwen-toSignedInt (- x y) bits)))
(define bs* (lambda (x y bits) (blodwen-toSignedInt (* x y) bits)))
(define bs/ (lambda (x y bits) (blodwen-toSignedInt (blodwen-euclidDiv x y) bits)))

(define (integer->bits8 x) (logand x (sub1 (ash 1 8))))
(define (integer->bits16 x) (logand x (sub1 (ash 1 16))))
(define (integer->bits32 x) (logand x (sub1 (ash 1 32))))
(define (integer->bits64 x) (logand x (sub1 (ash 1 64))))

(define (bits16->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits32->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits64->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits32->bits16 x) (logand x (sub1 (ash 1 16))))
(define (bits64->bits16 x) (logand x (sub1 (ash 1 16))))
(define (bits64->bits32 x) (logand x (sub1 (ash 1 32))))

(define (blodwen-bits-shl-signed x y bits) (blodwen-toSignedInt (ash x y) bits))

(define (blodwen-bits-shl x y bits) (logand (ash x y) (sub1 (ash 1 bits))))

(define blodwen-shl (lambda (x y) (ash x y)))
(define blodwen-shr (lambda (x y) (ash x (- y))))
(define blodwen-and (lambda (x y) (logand x y)))
(define blodwen-or (lambda (x y) (logor x y)))
(define blodwen-xor (lambda (x y) (logxor x y)))

(define cast-num
  (lambda (x)
    (if (number? x) x 0)))
(define destroy-prefix
  (lambda (x)
    (cond
      ((equal? x "") "")
      ((equal? (string-ref x 0) #\#) "")
      (else x))))

(define exact-floor
  (lambda (x)
    (inexact->exact (floor x))))

(define exact-truncate
  (lambda (x)
    (inexact->exact (truncate x))))

(define exact-truncate-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (exact-truncate x) y)))

(define exact-truncate-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (exact-truncate x) y)))

(define cast-char-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (char->integer x) y)))

(define cast-char-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (char->integer x) y)))

(define cast-string-int
  (lambda (x)
    (exact-truncate (cast-num (string->number (destroy-prefix x))))))

(define cast-string-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (cast-string-int x) y)))

(define cast-string-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (cast-string-int x) y)))

(define cast-int-char
  (lambda (x)
    (if (or
          (and (>= x 0) (<= x #xd7ff))
          (and (>= x #xe000) (<= x #x10ffff)))
        (integer->char x)
        (integer->char 0))))

(define cast-string-double
  (lambda (x)
    (exact->inexact (cast-num (string->number (destroy-prefix x))))))


(define (string-concat xs) (apply string-append xs))
(define (string-unpack s) (string->list s))
(define (string-pack xs) (list->string xs))

(define string-cons (lambda (x y) (string-append (string x) y)))
(define string-reverse (lambda (x)
  (list->string (reverse (string->list x)))))
(define (string-substr off len s)
    (let* ((l (string-length s))
          (b (max 0 off))
          (x (max 0 len))
          (end (min l (+ b x))))
          (if (> b l)
              ""
              (substring s b end))))

(define (blodwen-string-iterator-new s)
  0)

(define (blodwen-string-iterator-to-string _ s ofs f)
  (f (substring s ofs (string-length s))))

(define (blodwen-string-iterator-next s ofs)
  (if (>= ofs (string-length s))
      '() ; EOF
      (cons (string-ref s ofs) (+ ofs 1))))

(define either-left
  (lambda (x)
    (vector 0 x)))

(define either-right
  (lambda (x)
    (vector 1 x)))

(define blodwen-error-quit
  (lambda (msg)
    (display msg)
    (newline)
    (exit 1)))

(define (blodwen-get-line p)
    (if (port? p)
        (let ((str (get-line p)))
            (if (eof-object? str)
                ""
                str))
        void))

(define (blodwen-get-char p)
    (if (port? p)
        (let ((chr (get-char p)))
            (if (eof-object? chr)
                #\nul
                chr))
        void))

;; Buffers

(define (blodwen-new-buffer size)
  (make-bytevector size 0))

(define (blodwen-buffer-size buf)
  (bytevector-length buf))

(define (blodwen-buffer-setbyte buf loc val)
  (bytevector-u8-set! buf loc val))

(define (blodwen-buffer-getbyte buf loc)
  (bytevector-u8-ref buf loc))

(define (blodwen-buffer-setbits16 buf loc val)
  (bytevector-u16-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits16 buf loc)
  (bytevector-u16-ref buf loc (native-endianness)))

(define (blodwen-buffer-setbits32 buf loc val)
  (bytevector-u32-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits32 buf loc)
  (bytevector-u32-ref buf loc (native-endianness)))

(define (blodwen-buffer-setbits64 buf loc val)
  (bytevector-u64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits64 buf loc)
  (bytevector-u64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint8 buf loc val)
  (bytevector-s8-set! buf loc val))

(define (blodwen-buffer-getint8 buf loc)
  (bytevector-s8-ref buf loc))

(define (blodwen-buffer-setint16 buf loc val)
  (bytevector-s16-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint16 buf loc)
  (bytevector-s16-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint32 buf loc val)
  (bytevector-s32-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint32 buf loc)
  (bytevector-s32-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint buf loc val)
  (bytevector-s64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint buf loc)
  (bytevector-s64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint64 buf loc val)
  (bytevector-s64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint64 buf loc)
  (bytevector-s64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setdouble buf loc val)
  (bytevector-ieee-double-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getdouble buf loc)
  (bytevector-ieee-double-ref buf loc (native-endianness)))

(define (blodwen-stringbytelen str)
  (bytevector-length (string->utf8 str)))

(define (blodwen-buffer-setstring buf loc val)
  (let* [(strvec (string->utf8 val))
         (len (bytevector-length strvec))]
    (bytevector-copy! strvec 0 buf loc len)))

(define (blodwen-buffer-getstring buf loc len)
  (let [(newvec (make-bytevector len))]
    (bytevector-copy! buf loc newvec 0 len)
    (utf8->string newvec)))

(define (blodwen-buffer-copydata buf start len dest loc)
  (bytevector-copy! buf start dest loc len))

;; Threads

(define-record thread-handle (semaphore))

(define (blodwen-thread proc)
  (let [(sema (blodwen-make-semaphore 0))]
    (fork-thread (lambda () (proc (vector 0)) (blodwen-semaphore-post sema)))
    (make-thread-handle sema)
    ))

(define (blodwen-thread-wait handle)
  (blodwen-semaphore-wait (thread-handle-semaphore handle)))

;; Thread mailboxes

(define blodwen-thread-data
  (make-thread-parameter #f))

(define (blodwen-get-thread-data ty)
  (blodwen-thread-data))

(define (blodwen-set-thread-data ty a)
  (blodwen-thread-data a))

;; Semaphore

(define-record semaphore (box mutex condition))

(define (blodwen-make-semaphore init)
  (make-semaphore (box init) (make-mutex) (make-condition)))

(define (blodwen-semaphore-post sema)
  (with-mutex (semaphore-mutex sema)
    (let [(sema-box (semaphore-box sema))]
      (set-box! sema-box (+ (unbox sema-box) 1))
      (condition-signal (semaphore-condition sema))
    )))

(define (blodwen-semaphore-wait sema)
  (with-mutex (semaphore-mutex sema)
    (let [(sema-box (semaphore-box sema))]
      (when (= (unbox sema-box) 0)
        (condition-wait (semaphore-condition sema) (semaphore-mutex sema)))
      (set-box! sema-box (- (unbox sema-box) 1))
      )))

;; Barrier

(define-record barrier (count-box num-threads mutex cond))

(define (blodwen-make-barrier num-threads)
  (make-barrier (box 0) num-threads (make-mutex) (make-condition)))

(define (blodwen-barrier-wait barrier)
  (let [(count-box (barrier-count-box barrier))
        (num-threads (barrier-num-threads barrier))
        (mutex (barrier-mutex barrier))
        (condition (barrier-cond barrier))]
    (with-mutex mutex
    (let* [(count-old (unbox count-box))
           (count-new (+ count-old 1))]
      (set-box! count-box count-new)
      (if (= count-new num-threads)
          (condition-broadcast condition)
          (condition-wait condition mutex))
      ))))

;; Channel
; With thanks to Alain Zscheile (@zseri) for help with understanding condition
; variables, and figuring out where the problems were and how to solve them.

(define-record channel (read-mut read-cv read-box val-cv val-box))

(define (blodwen-make-channel ty)
  (make-channel
    (make-mutex)
    (make-condition)
    (box #t)
    (make-condition)
    (box '())
    ))

; block on the read status using read-cv until the value has been read
(define (channel-put-while-helper chan)
  (let ([read-mut (channel-read-mut chan)]
        [read-box (channel-read-box chan)]
        [read-cv  (channel-read-cv  chan)]
        )
    (if (unbox read-box)
      (void)    ; val has been read, so everything is fine
      (begin    ; otherwise, block/spin with cv
        (condition-wait read-cv read-mut)
        (channel-put-while-helper chan)
        )
      )))

(define (blodwen-channel-put ty chan val)
  (with-mutex (channel-read-mut chan)
    (channel-put-while-helper chan)
    (let ([read-box (channel-read-box chan)]
          [val-box  (channel-val-box  chan)]
          )
      (set-box! val-box val)
      (set-box! read-box #f)
      ))
  (condition-signal (channel-val-cv chan))
  )

; block on the value until it has been set
(define (channel-get-while-helper chan)
  (let ([read-mut (channel-read-mut chan)]
        [read-box (channel-read-box chan)]
        [val-cv   (channel-val-cv   chan)]
        )
    (if (unbox read-box)
      (begin
        (condition-wait val-cv read-mut)
        (channel-get-while-helper chan)
        )
      (void)
      )))

(define (blodwen-channel-get ty chan)
  (mutex-acquire (channel-read-mut chan))
  (channel-get-while-helper chan)
  (let* ([val-box  (channel-val-box  chan)]
         [read-box (channel-read-box chan)]
         [read-cv  (channel-read-cv  chan)]
         [the-val  (unbox val-box)]
         )
    (set-box! val-box '())
    (set-box! read-box #t)
    (mutex-release (channel-read-mut chan))
    (condition-signal read-cv)
    the-val))

(define (blodwen-channel-get-non-blocking ty chan)
  (if (mutex-acquire (channel-read-mut chan) #f)
    (let* ([val-box  (channel-val-box  chan)]
           [read-box (channel-read-box chan)]
           [read-cv  (channel-read-cv  chan)]
           [the-val  (unbox val-box)]
          )
      (if (null? the-val)
          (begin
           (mutex-release (channel-read-mut chan))
           '())
          (begin
            (set-box! val-box '())
            (set-box! read-box #t)
            (mutex-release (channel-read-mut chan))
            (condition-signal read-cv)
            (box the-val))
      ))
  '()))

(define (blodwen-channel-get-with-timeout ty chan timeout)
  ;; timeout is in milliseconds, convert to nanoseconds
  (let* ([timeout-ns (* timeout 1000000)]
         [sleep-ns 10000] ; 10 us step
         [sleep-time (make-time 'time-duration (mod sleep-ns 1000000000)
                                                (div sleep-ns 1000000000))])
    (let loop ([elapsed 0])
      (if (mutex-acquire (channel-read-mut chan) #f)
          (let* ([val-box  (channel-val-box chan)]
                 [the-val  (unbox val-box)])
            (if (null? the-val)
                (if (>= elapsed timeout-ns)
                    (begin
                      (mutex-release (channel-read-mut chan))
                      '())
                    (begin
                      (mutex-release (channel-read-mut chan))
                      (sleep sleep-time)
                      (loop (+ elapsed sleep-ns))))
                (let* ([read-box (channel-read-box chan)]
                       [read-cv  (channel-read-cv chan)])
                  (set-box! val-box '())
                  (set-box! read-box #t)
                  (mutex-release (channel-read-mut chan))
                  (condition-signal read-cv)
                  (box the-val))))
          (begin
            (sleep sleep-time)
            (loop (+ elapsed sleep-ns)))))))

;; Mutex

(define (blodwen-make-mutex)
  (make-mutex))
(define (blodwen-mutex-acquire mutex)
  (mutex-acquire mutex))
(define (blodwen-mutex-release mutex)
  (mutex-release mutex))

;; Condition variable

(define (blodwen-make-condition)
  (make-condition))
(define (blodwen-condition-wait condition mutex)
  (condition-wait condition mutex))
(define (blodwen-condition-wait-timeout condition mutex timeout)
  (let* [(sec (div timeout 1000000))
         (micro (mod timeout 1000000))]
    (condition-wait condition mutex (make-time 'time-duration (* 1000 micro) sec))))
(define (blodwen-condition-signal condition)
  (condition-signal condition))
(define (blodwen-condition-broadcast condition)
  (condition-broadcast condition))

;; Future

(define-record future-internal (result ready mutex signal))
(define (blodwen-make-future ty work)
  (let ([future (make-future-internal #f #f (make-mutex) (make-condition))])
    (fork-thread (lambda ()
      (let ([result (work '())])
        (with-mutex (future-internal-mutex future)
          (set-future-internal-result! future result)
          (set-future-internal-ready! future #t)
          (condition-broadcast (future-internal-signal future))))))
    future))
(define (blodwen-await-future ty future)
  (let ([mutex (future-internal-mutex future)])
    (with-mutex mutex
      (if (not (future-internal-ready future))
          (condition-wait (future-internal-signal future) mutex))
      (future-internal-result future))))

(define (blodwen-sleep s) (sleep (make-time 'time-duration 0 s)))
(define (blodwen-usleep s)
  (let ((sec (div s 1000000))
        (micro (mod s 1000000)))
       (sleep (make-time 'time-duration (* 1000 micro) sec))))

(define (blodwen-clock-time-utc) (current-time 'time-utc))
(define (blodwen-clock-time-monotonic) (current-time 'time-monotonic))
(define (blodwen-clock-time-duration) (current-time 'time-duration))
(define (blodwen-clock-time-process) (current-time 'time-process))
(define (blodwen-clock-time-thread) (current-time 'time-thread))
(define (blodwen-clock-time-gccpu) (current-time 'time-collector-cpu))
(define (blodwen-clock-time-gcreal) (current-time 'time-collector-real))
(define (blodwen-is-time? clk) (if (time? clk) 1 0))
(define (blodwen-clock-second time) (time-second time))
(define (blodwen-clock-nanosecond time) (time-nanosecond time))

(define (blodwen-arg-count)
  (length (command-line)))

(define (blodwen-arg n)
  (if (< n (length (command-line))) (list-ref (command-line) n) ""))

(define (blodwen-hasenv var)
  (if (eq? (getenv var) #f) 0 1))

;; Randoms
(define random-seed-register 0)
(define (initialize-random-seed-once)
  (if (= (virtual-register random-seed-register) 0)
      (let ([seed (time-nanosecond (current-time))])
        (set-virtual-register! random-seed-register seed)
        (random-seed seed))))

(define (blodwen-random-seed seed)
  (set-virtual-register! random-seed-register seed)
  (random-seed seed))
(define blodwen-random
  (case-lambda
    ;; no argument, pick a real value from [0, 1.0)
    [() (begin
          (initialize-random-seed-once)
          (random 1.0))]
    ;; single argument k, pick an integral value from [0, k)
    [(k)
      (begin
        (initialize-random-seed-once)
        (if (> k 0)
              (random k)
              (assertion-violationf 'blodwen-random "invalid range argument ~a" k)))]))

;; For finalisers

(define blodwen-finaliser (make-guardian))
(define (blodwen-register-object obj proc)
  (let [(x (cons obj proc))]
       (blodwen-finaliser x)
       x))
(define blodwen-run-finalisers
  (lambda ()
    (let run ()
      (let ([x (blodwen-finaliser)])
        (when x
          (((cdr x) (car x)) 'erased)
          (run))))))

;; For creating and reading back scheme objects

; read a scheme string and evaluate it, returning 'Just result' on success
; TODO: catch exception!
(define (blodwen-eval-scheme str)
  (guard
     (x [#t '()]) ; Nothing on failure
     (box (eval (read (open-input-string str)))))
  ); box == Just

(define (blodwen-eval-okay obj)
  (if (null? obj)
      0
      1))

(define (blodwen-get-eval-result obj)
  (unbox obj))

(define (blodwen-debug-scheme obj)
  (display obj) (newline))

(define (blodwen-is-number obj)
  (if (number? obj) 1 0))

(define (blodwen-is-integer obj)
  (if (and (number? obj) (exact? obj)) 1 0))

(define (blodwen-is-float obj)
  (if (flonum? obj) 1 0))

(define (blodwen-is-char obj)
  (if (char? obj) 1 0))

(define (blodwen-is-string obj)
  (if (string? obj) 1 0))

(define (blodwen-is-procedure obj)
  (if (procedure? obj) 1 0))

(define (blodwen-is-symbol obj)
  (if (symbol? obj) 1 0))

(define (blodwen-is-vector obj)
  (if (vector? obj) 1 0))

(define (blodwen-is-nil obj)
  (if (null? obj) 1 0))

(define (blodwen-is-pair obj)
  (if (pair? obj) 1 0))

(define (blodwen-is-box obj)
  (if (box? obj) 1 0))

(define (blodwen-make-symbol str)
  (string->symbol str))

; The below rely on checking that the objects are the right type first.

(define (blodwen-vector-ref obj i)
  (vector-ref obj i))

(define (blodwen-vector-length obj)
  (vector-length obj))

(define (blodwen-vector-list obj)
  (vector->list obj))

(define (blodwen-unbox obj)
  (unbox obj))

(define (blodwen-apply obj arg)
  (obj arg))

(define (blodwen-force obj)
  (obj))

(define (blodwen-read-symbol sym)
  (symbol->string sym))

(define (blodwen-id x) x)
(define PreludeC-45Types-fastUnpack (lambda (farg-0) (string-unpack farg-0)))
(define PreludeC-45Types-fastPack (lambda (farg-0) (string-pack farg-0)))
(define PreludeC-45IO-prim__putStr (lambda (farg-0 farg-1) ((foreign-procedure "idris2_putStr" (string) void) farg-0)))
(define PreludeC-45Types-isSpace (lambda (arg-0) (cond ((equal? arg-0 #\ ) 1) ((equal? arg-0 (integer->char 9)) 1) ((equal? arg-0 (integer->char 13)) 1) ((equal? arg-0 (integer->char 10)) 1) ((equal? arg-0 (integer->char 12)) 1) ((equal? arg-0 (integer->char 11)) 1) ((equal? arg-0 (integer->char 160)) 1)(else 0))))
(define Parser-satisfy (lambda (arg-0 ext-0) (if (null? ext-0) (vector 0 (vector 1 "Unexpected end of input")) (let ((e-2 (car ext-0))) (let ((e-3 (cdr ext-0))) (let ((sc1 (arg-0 e-2))) (cond ((equal? sc1 1) (vector 1 (cons e-2 e-3))) (else (vector 0 (vector 1 (string-append "unexpected " (PreludeC-45Types-fastPack (cons e-2 '())))))))))))))
(define csegen-6 (lambda (eta-0) (Parser-satisfy (lambda (eta-1) (PreludeC-45Types-isSpace eta-1)) eta-0)))
(define PreludeC-45EqOrd-u--C-60C-61_Ord_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char<=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-62C-61_Ord_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char>=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45Types-isUpper (lambda (arg-0) (let ((sc0 (PreludeC-45EqOrd-u--C-62C-61_Ord_Char arg-0 #\A))) (cond ((equal? sc0 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Char arg-0 #\Z)) (else 0)))))
(define csegen-15 (lambda (eta-0) (Parser-satisfy (lambda (eta-1) (PreludeC-45Types-isUpper eta-1)) eta-0)))
(define PreludeC-45Types-isLower (lambda (arg-0) (let ((sc0 (PreludeC-45EqOrd-u--C-62C-61_Ord_Char arg-0 #\a))) (cond ((equal? sc0 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Char arg-0 #\z)) (else 0)))))
(define PreludeC-45Types-isAlpha (lambda (arg-0) (let ((sc0 (PreludeC-45Types-isUpper arg-0))) (cond ((equal? sc0 1) 1) (else (PreludeC-45Types-isLower arg-0))))))
(define PreludeC-45Types-isDigit (lambda (arg-0) (let ((sc0 (PreludeC-45EqOrd-u--C-62C-61_Ord_Char arg-0 #\0))) (cond ((equal? sc0 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Char arg-0 #\9)) (else 0)))))
(define PreludeC-45Types-isAlphaNum (lambda (arg-0) (let ((sc0 (PreludeC-45Types-isDigit arg-0))) (cond ((equal? sc0 1) 1) (else (PreludeC-45Types-isAlpha arg-0))))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define Parser-identChar (lambda (arg-0) (let ((sc0 (PreludeC-45Types-isAlphaNum arg-0))) (cond ((equal? sc0 1) 1) (else (PreludeC-45EqOrd-u--C-61C-61_Eq_Char arg-0 #\_))))))
(define csegen-16 (lambda (eta-0) (Parser-satisfy (lambda (eta-1) (Parser-identChar eta-1)) eta-0)))
(define Parser-case--many1-1969 (lambda (arg-1 arg-2 arg-3) (case (vector-ref arg-3 0) ((0) (let ((e-2 (vector-ref arg-3 1))) (vector 0 e-2))) (else (let ((e-5 (vector-ref arg-3 1))) (let ((e-8 (car e-5))) (let ((e-9 (cdr e-5))) (let ((sc2 (Parser-many1 arg-1 e-9))) (case (vector-ref sc2 0) ((0) (vector 1 (cons (cons e-8 '()) e-9))) (else (let ((e-6 (vector-ref sc2 1))) (let ((e-11 (car e-6))) (let ((e-10 (cdr e-6))) (let ((e-12 (car e-11))) (let ((e-13 (cdr e-11))) (vector 1 (cons (cons e-8 (cons e-12 e-13)) e-10)))))))))))))))))
(define Parser-many1 (lambda (arg-1 ext-0) (Parser-case--many1-1969 arg-1 ext-0 (arg-1 ext-0))))
(define Parser-many0 (lambda (arg-1 ext-0) (let ((sc0 (Parser-many1 arg-1 ext-0))) (case (vector-ref sc0 0) ((0) (vector 1 (cons '() ext-0))) (else (let ((e-5 (vector-ref sc0 1))) (let ((e-8 (car e-5))) (let ((e-9 (cdr e-5))) (let ((e-12 (car e-8))) (let ((e-13 (cdr e-8))) (vector 1 (cons (cons e-12 e-13) e-9))))))))))))
(define csegen-17 (lambda (eta-0) (Parser-many0 csegen-16 eta-0)))
(define PreludeC-45Types-u--foldl_Foldable_List (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (PreludeC-45Types-u--foldl_Foldable_List arg-2 ((arg-2 arg-3) e-2) e-3))))))
(define PreludeC-45Types-u--foldMap_Foldable_List (lambda (arg-2 arg-3 ext-0) (PreludeC-45Types-u--foldl_Foldable_List (lambda (u--acc) (lambda (u--elem) (let ((e-1 (car arg-2))) ((e-1 u--acc) (arg-3 u--elem))))) (let ((e-2 (cdr arg-2))) e-2) ext-0)))
(define PreludeC-45Basics-flip (lambda (arg-3 ext-0 ext-1) ((arg-3 ext-1) ext-0)))
(define PreludeC-45Types-u--foldlM_Foldable_List (lambda (arg-3 arg-4 arg-5 ext-0) (PreludeC-45Types-u--foldl_Foldable_List (lambda (u--ma) (lambda (u--b) (let ((e-2 (vector-ref arg-3 1))) ((((e-2 'erased) 'erased) u--ma) (lambda (eta-0) (PreludeC-45Basics-flip arg-4 u--b eta-0)))))) (let ((e-1 (vector-ref arg-3 0))) (let ((e-5 (vector-ref e-1 1))) ((e-5 'erased) arg-5))) ext-0)))
(define PreludeC-45Types-u--foldr_Foldable_List (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) ((arg-2 e-2) (PreludeC-45Types-u--foldr_Foldable_List arg-2 arg-3 e-3)))))))
(define PreludeC-45Types-u--null_Foldable_List (lambda (arg-1) (if (null? arg-1) 1 0)))
(define csegen-32 (vector (lambda (u--acc) (lambda (u--elem) (lambda (u--func) (lambda (u--init) (lambda (u--input) (PreludeC-45Types-u--foldr_Foldable_List u--func u--init u--input)))))) (lambda (u--elem) (lambda (u--acc) (lambda (u--func) (lambda (u--init) (lambda (u--input) (PreludeC-45Types-u--foldl_Foldable_List u--func u--init u--input)))))) (lambda (u--elem) (lambda (arg-10947) (PreludeC-45Types-u--null_Foldable_List arg-10947))) (lambda (u--elem) (lambda (u--acc) (lambda (u--m) (lambda (i_con-0) (lambda (u--funcM) (lambda (u--init) (lambda (u--input) (PreludeC-45Types-u--foldlM_Foldable_List i_con-0 u--funcM u--init u--input)))))))) (lambda (u--elem) (lambda (arg-10976) arg-10976)) (lambda (u--a) (lambda (u--m) (lambda (i_con-0) (lambda (u--f) (lambda (arg-10990) (PreludeC-45Types-u--foldMap_Foldable_List i_con-0 u--f arg-10990))))))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_String (lambda (arg-0 arg-1) (let ((sc0 (or (and (string=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_String (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_String arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define csegen-35 (cons (lambda (arg-712) (lambda (arg-715) (PreludeC-45EqOrd-u--C-61C-61_Eq_String arg-712 arg-715))) (lambda (arg-722) (lambda (arg-725) (PreludeC-45EqOrd-u--C-47C-61_Eq_String arg-722 arg-725)))))
(define Parser-char (lambda (arg-0 ext-0) (Parser-satisfy (lambda (arg-1) (PreludeC-45EqOrd-u--C-61C-61_Eq_Char arg-1 arg-0)) ext-0)))
(define csegen-47 (lambda (eta-0) (Parser-char #\( eta-0)))
(define csegen-48 (lambda (eta-0) (Parser-char #\: eta-0)))
(define csegen-49 (lambda (eta-0) (Parser-char #\) eta-0)))
(define csegen-59 (lambda (eta-0) (Parser-char #\= eta-0)))
(define csegen-73 (lambda (eta-0) (Parser-satisfy (lambda (eta-1) (PreludeC-45Types-isDigit eta-1)) eta-0)))
(define u--prim__sub_Integer (lambda (arg-0 arg-1) (- arg-0 arg-1)))
(define Typechecker-eq (lambda (arg-0 arg-1) (if (null? arg-0) (if (null? arg-1) 1 0) (let ((e-4 (unbox arg-0))) (if (null? arg-1) 0 (let ((e-5 (unbox arg-1))) (PreludeC-45EqOrd-u--C-61C-61_Eq_String e-4 e-5)))))))
(define PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (lambda (arg-3 arg-4) (case (vector-ref arg-3 0) ((0) (let ((e-2 (vector-ref arg-3 1))) (vector 0 e-2))) (else (let ((e-5 (vector-ref arg-3 1))) (arg-4 e-5))))))
(define Typechecker-check_args_types (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (if (null? arg-3) (case (vector-ref arg-4 0) ((0) (vector 1 (vector 0 )))(else (vector 0 (vector 0 "bad number of arguments")))) (let ((e-6 (car arg-3))) (let ((e-7 (cdr arg-3))) (case (vector-ref arg-4 0) ((1) (let ((e-9 (vector-ref arg-4 2))) (let ((e-10 (vector-ref arg-4 3))) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-check_prod_type arg-0 arg-1 arg-2 e-6 e-9) (lambda (u--arg2) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-check_args_types arg-0 arg-1 arg-2 e-7 e-10) (lambda (u--rest2) (vector 1 (vector 1 u--arg2 u--rest2)))))))))(else (vector 0 (vector 0 "bad number of arguments")))))))))
(define Typechecker-n--3271-1715-u--findInConstructors (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (if (null? arg-4) '() (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (let ((e-6 (car e-2))) (let ((e-7 (cdr e-2))) (let ((sc2 (PreludeC-45EqOrd-u--C-61C-61_Eq_String e-6 arg-3))) (cond ((equal? sc2 1) (box e-7)) (else (Typechecker-n--3271-1715-u--findInConstructors arg-0 arg-1 arg-2 arg-3 e-3)))))))))))
(define Typechecker-lookupConstructor (lambda (arg-0 arg-1) (if (null? arg-1) (vector 0 (vector 0 (string-append "constructor not found: " arg-0))) (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (case (vector-ref e-2 0) ((0) (let ((e-0 (vector-ref e-2 1))) (let ((e-1 (vector-ref e-2 2))) (let ((u--decl (vector 0 e-0 e-1))) (let ((sc2 (Typechecker-n--3271-1715-u--findInConstructors u--decl e-3 arg-0 arg-0 e-1))) (if (null? sc2) (Typechecker-lookupConstructor arg-0 e-3) (let ((e-4 (unbox sc2))) (vector 1 (cons e-4 (box e-0))))))))))(else (Typechecker-lookupConstructor arg-0 e-3))))))))
(define PreludeC-45TypesC-45List-lengthPlus (lambda (arg-1 arg-2) (if (null? arg-2) arg-1 (let ((e-3 (cdr arg-2))) (PreludeC-45TypesC-45List-lengthPlus (+ arg-1 1) e-3)))))
(define PreludeC-45TypesC-45List-lengthTR (lambda (ext-0) (PreludeC-45TypesC-45List-lengthPlus 0 ext-0)))
(define Typechecker-extendRenames (lambda (arg-0 arg-1) (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (cons (+ e-2 1) (cons (cons arg-0 e-2) e-3))))))
(define Typechecker-n--3228-2291-u--extendBranchVars (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-7 arg-8) (if (null? arg-7) (case (vector-ref arg-8 0) ((0) (cons arg-5 arg-6))(else (cons arg-5 arg-6))) (let ((e-2 (car arg-7))) (let ((e-3 (cdr arg-7))) (if (null? e-2) (cons arg-5 arg-6) (let ((e-6 (car e-2))) (case (vector-ref arg-8 0) ((1) (let ((e-8 (vector-ref arg-8 1))) (let ((e-9 (vector-ref arg-8 2))) (let ((e-10 (vector-ref arg-8 3))) (let ((u--rensC-39 (Typechecker-extendRenames e-6 arg-5))) (let ((u--gamC-39 (vector 1 e-8 e-9 arg-6))) (let ((sc3 (Typechecker-n--3228-2291-u--extendBranchVars arg-0 arg-1 arg-2 arg-3 arg-4 u--rensC-39 u--gamC-39 e-3 e-10))) (let ((e-5 (car sc3))) (let ((e-4 (cdr sc3))) (cons e-5 e-4))))))))))(else (cons arg-5 arg-6))))))))))
(define PreludeC-45Types-prim__integerToNat (lambda (arg-0) (let ((sc0 (or (and (<= 0 arg-0) 1) 0))) (cond ((equal? sc0 0) 0)(else arg-0)))))
(define Typechecker-n--3228-2292-u--varsToArgs (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-7) (if (null? arg-6) (case (vector-ref arg-7 0) ((0) (vector 0 ))(else (vector 0 ))) (let ((e-3 (cdr arg-6))) (case (vector-ref arg-7 0) ((1) (let ((e-4 (vector-ref arg-7 1))) (let ((e-6 (vector-ref arg-7 3))) (cond ((equal? e-4 0) (vector 1 (vector 1 (PreludeC-45Types-prim__integerToNat (- arg-5 1))) (Typechecker-n--3228-2292-u--varsToArgs arg-0 arg-1 arg-2 arg-3 arg-4 (PreludeC-45Types-prim__integerToNat (- arg-5 1)) e-3 e-6))) ((equal? e-4 1) (vector 2 (PreludeC-45Types-prim__integerToNat (- arg-5 1)) (Typechecker-n--3228-2292-u--varsToArgs arg-0 arg-1 arg-2 arg-3 arg-4 (PreludeC-45Types-prim__integerToNat (- arg-5 1)) e-3 e-6)))(else (vector 0 ))))))(else (vector 0 )))))))
(define Typechecker-case--caseC-32blockC-32inC-32check_case_branches-2498 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-7 arg-8 arg-9) (case (vector-ref arg-9 0) ((1) (let ((e-2 (vector-ref arg-9 1))) (let ((e-8 (car e-2))) (let ((sc2 (Typechecker-n--3228-2291-u--extendBranchVars arg-0 arg-8 arg-1 arg-2 arg-3 arg-3 arg-1 arg-5 e-8))) (let ((e-4 (car sc2))) (let ((e-3 (cdr sc2))) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-check_prod_type e-4 arg-2 e-3 arg-6 arg-0) (lambda (u--body2) (vector 1 (cons arg-4 (cons (Typechecker-n--3228-2292-u--varsToArgs arg-0 arg-8 arg-1 arg-2 arg-3 (PreludeC-45TypesC-45List-lengthTR arg-5) arg-5 e-8) u--body2))))))))))) (else (let ((e-5 (vector-ref arg-9 1))) (vector 0 e-5))))))
(define Typechecker-check_case_branches (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (if (null? arg-3) (vector 1 '()) (let ((e-2 (car arg-3))) (let ((e-3 (cdr arg-3))) (let ((e-6 (car e-2))) (let ((e-7 (cdr e-2))) (let ((e-10 (car e-7))) (let ((e-11 (cdr e-7))) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (let ((u--branches (cons (cons e-6 (cons e-10 e-11)) e-3))) (Typechecker-case--caseC-32blockC-32inC-32check_case_branches-2498 arg-4 arg-2 arg-1 arg-0 e-6 e-10 e-11 e-3 u--branches (Typechecker-lookupConstructor e-6 arg-1))) (lambda (u--branchResult) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-check_case_branches arg-0 arg-1 arg-2 e-3 arg-4) (lambda (u--rest2) (vector 1 (cons u--branchResult u--rest2)))))))))))))))
(define Typechecker-n--3249-2022-u--extendBranchVars (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-7 arg-8 arg-9) (if (null? arg-8) (case (vector-ref arg-9 0) ((0) (cons arg-6 arg-7))(else (cons arg-6 arg-7))) (let ((e-2 (car arg-8))) (let ((e-3 (cdr arg-8))) (if (null? e-2) (cons arg-6 arg-7) (let ((e-6 (car e-2))) (case (vector-ref arg-9 0) ((1) (let ((e-8 (vector-ref arg-9 1))) (let ((e-9 (vector-ref arg-9 2))) (let ((e-10 (vector-ref arg-9 3))) (let ((u--rensC-39 (Typechecker-extendRenames e-6 arg-6))) (let ((u--gamC-39 (vector 1 e-8 e-9 arg-7))) (let ((sc3 (Typechecker-n--3249-2022-u--extendBranchVars arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 u--rensC-39 u--gamC-39 e-3 e-10))) (let ((e-5 (car sc3))) (let ((e-4 (cdr sc3))) (cons e-5 e-4))))))))))(else (cons arg-6 arg-7))))))))))
(define Typechecker-case--caseC-32blockC-32inC-32caseC-32blockC-32inC-32infer_first_branch-2195 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-7 arg-8 arg-9 arg-10) (let ((e-2 (car arg-10))) (let ((e-3 (cdr arg-10))) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-infer_prod_type e-2 arg-3 e-3 arg-7) (lambda (_-0) (let ((e-4 (cdr _-0))) (vector 1 e-4))))))))
(define Typechecker-infer_first_branch (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5) (if (null? arg-4) (vector 0 (vector 0 (string-append "missing case branch for constructor " arg-3))) (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (let ((e-6 (car e-2))) (let ((e-7 (cdr e-2))) (let ((e-10 (car e-7))) (let ((e-11 (cdr e-7))) (let ((u--branches (cons (cons e-6 (cons e-10 e-11)) e-3))) (let ((sc3 (PreludeC-45EqOrd-u--C-61C-61_Eq_String e-6 arg-3))) (cond ((equal? sc3 1) (Typechecker-case--caseC-32blockC-32inC-32caseC-32blockC-32inC-32infer_first_branch-2195 arg-5 arg-3 arg-2 arg-1 arg-0 e-6 e-10 e-11 e-3 u--branches (Typechecker-n--3249-2022-u--extendBranchVars arg-5 u--branches arg-3 arg-2 arg-1 arg-0 arg-0 arg-2 e-10 arg-5))) (else (Typechecker-infer_first_branch arg-0 arg-1 arg-2 arg-3 e-3 arg-5))))))))))))))
(define Typechecker-case--lookupGamma-1249 (lambda (arg-0 arg-1 arg-2) (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (case (vector-ref e-3 0) ((0) (Typechecker-lookupGamma arg-1 arg-0))(else (cond ((equal? e-2 0) (let ((e-6 (vector-ref e-3 2))) e-6))(else (let ((e-4 (- e-2 1))) (let ((e-10 (vector-ref e-3 3))) (Typechecker-lookupGamma e-4 e-10)))))))))))
(define Typechecker-lookupGamma (lambda (arg-0 arg-1) (Typechecker-case--lookupGamma-1249 arg-1 arg-0 (cons arg-0 arg-1))))
(define Typechecker-lookupRename (lambda (arg-0 arg-1) (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (if (null? e-3) (vector 0 (vector 1 (string-append "undefined variable " arg-0))) (let ((e-6 (car e-3))) (let ((e-7 (cdr e-3))) (let ((e-10 (car e-6))) (let ((e-11 (cdr e-6))) (let ((sc3 (PreludeC-45EqOrd-u--C-61C-61_Eq_String e-10 arg-0))) (cond ((equal? sc3 1) (vector 1 e-11)) (else (Typechecker-lookupRename arg-0 (cons e-2 e-7))))))))))))))
(define Typechecker-lookupTheta (lambda (arg-0 arg-1) (if (null? arg-1) (vector 0 (vector 1 (string-append "undefined declaration " arg-0))) (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (case (vector-ref e-2 0) ((0) (let ((e-0 (vector-ref e-2 1))) (let ((e-1 (vector-ref e-2 2))) (let ((u--decl (vector 0 e-0 e-1))) (let ((sc2 (PreludeC-45EqOrd-u--C-61C-61_Eq_String e-0 arg-0))) (cond ((equal? sc2 1) (vector 1 u--decl)) (else (Typechecker-lookupTheta arg-0 e-3)))))))) ((1) (let ((e-5 (vector-ref e-2 1))) (let ((e-4 (vector-ref e-2 2))) (let ((u--decl (vector 1 e-5 e-4))) (let ((sc2 (PreludeC-45EqOrd-u--C-61C-61_Eq_String e-5 arg-0))) (cond ((equal? sc2 1) (vector 1 u--decl)) (else (Typechecker-lookupTheta arg-0 e-3)))))))) (else (let ((e-4 (vector-ref e-2 1))) (let ((e-5 (vector-ref e-2 2))) (let ((e-6 (vector-ref e-2 3))) (let ((e-7 (vector-ref e-2 4))) (let ((u--decl (vector 2 e-4 e-5 e-6 e-7))) (let ((sc2 (PreludeC-45EqOrd-u--C-61C-61_Eq_String e-4 arg-0))) (cond ((equal? sc2 1) (vector 1 u--decl)) (else (Typechecker-lookupTheta arg-0 e-3))))))))))))))))
(define Typechecker-infer_prod_type (lambda (arg-0 arg-1 arg-2 arg-3) (case (vector-ref arg-3 0) ((1) (let ((e-0 (vector-ref arg-3 1))) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-lookupRename e-0 arg-0) (lambda (u--idx) (vector 1 (cons (vector 1 u--idx) (Typechecker-lookupGamma u--idx arg-2))))))) ((0) (let ((e-1 (vector-ref arg-3 1))) (vector 1 (cons (vector 0 e-1) '())))) ((7) (let ((e-2 (vector-ref arg-3 1))) (let ((e-3 (vector-ref arg-3 2))) (let ((e-4 (vector-ref arg-3 3))) (let ((e-5 (vector-ref arg-3 4))) (if (null? e-3) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-infer_prod_type arg-0 arg-1 arg-2 e-4) (lambda (_-0) (let ((e-7 (car _-0))) (let ((e-6 (cdr _-0))) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-infer_prod_type (Typechecker-extendRenames e-2 arg-0) arg-1 (vector 1 0 e-6 arg-2) e-5) (lambda (_-1) (let ((e-9 (car _-1))) (let ((e-8 (cdr _-1))) (vector 1 (cons (vector 2 e-7 e-9) e-8)))))))))) (let ((e-17 (unbox e-3))) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-check_prod_type arg-0 arg-1 arg-2 e-4 e-17) (lambda (u--v2) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-infer_prod_type (Typechecker-extendRenames e-2 arg-0) arg-1 (vector 1 0 e-17 arg-2) e-5) (lambda (_-0) (let ((e-7 (car _-0))) (let ((e-6 (cdr _-0))) (vector 1 (cons (vector 2 u--v2 e-7) e-6))))))))))))))) ((4) (let ((e-6 (vector-ref arg-3 1))) (let ((e-7 (vector-ref arg-3 2))) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-infer_prod_type arg-0 arg-1 arg-2 e-6) (lambda (_-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (if (null? e-3) (vector 0 (vector 0 "Case not implemented")) (let ((e-0 (unbox e-3))) (let ((sc3 (Typechecker-lookupTheta e-0 arg-1))) (case (vector-ref sc3 0) ((1) (let ((e-4 (vector-ref sc3 1))) (case (vector-ref e-4 0) ((0) (let ((e-8 (vector-ref e-4 2))) (if (null? e-8) (vector 0 (vector 0 "Can't infer type of empty case statement")) (let ((e-16 (car e-8))) (let ((e-20 (car e-16))) (let ((e-21 (cdr e-16))) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-infer_first_branch arg-0 arg-1 arg-2 e-20 e-7 e-21) (lambda (u--retType) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-check_case_branches arg-0 arg-1 arg-2 e-7 u--retType) (lambda (u--branches2) (vector 1 (cons (vector 5 e-2 u--branches2) u--retType)))))))))))) ((1) (vector 0 (vector 0 "Can't scrutinize codata"))) (else (vector 0 (vector 0 "Can't scrutinize function")))))) (else (let ((e-5 (vector-ref sc3 1))) (vector 0 e-5)))))))))))))) ((5) (vector 0 (vector 0 "Object not implemented"))) ((6) (vector 0 (vector 0 "MethodApp not implemented"))) ((2) (vector 0 (vector 0 "GlobalApp not implemented"))) (else (let ((e-14 (vector-ref arg-3 1))) (let ((e-15 (vector-ref arg-3 2))) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-lookupConstructor e-14 arg-1) (lambda (_-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-check_args_types arg-0 arg-1 arg-2 e-15 e-2) (lambda (u--args2) (vector 1 (cons (vector 4 e-14 u--args2) e-3))))))))))))))
(define Typechecker-n--3164-2792-u--show (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5) (if (null? arg-5) "Int" (let ((e-0 (unbox arg-5))) e-0))))
(define Typechecker-check_prod_type (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-infer_prod_type arg-0 arg-1 arg-2 arg-3) (lambda (_-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (let ((sc1 (Typechecker-eq arg-4 e-3))) (cond ((equal? sc1 1) (vector 1 e-2)) (else (vector 0 (vector 0 (string-append "Type mismatch: expected " (string-append (Typechecker-n--3164-2792-u--show arg-4 arg-3 arg-2 arg-1 arg-0 arg-4) (string-append ", got " (Typechecker-n--3164-2792-u--show arg-4 arg-3 arg-2 arg-1 arg-0 e-3)))))))))))))))
(define Typechecker-convertGammaSyntax (lambda (arg-0) (if (null? arg-0) (vector 0 ) (let ((e-2 (car arg-0))) (let ((e-3 (cdr arg-0))) (let ((e-7 (cdr e-2))) (vector 1 0 e-7 (Typechecker-convertGammaSyntax e-3))))))))
(define PreludeC-45TypesC-45SnocList-C-60C-62C-62 (lambda (arg-1 arg-2) (if (null? arg-1) arg-2 (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 e-2 (cons e-3 arg-2)))))))
(define PreludeC-45TypesC-45List-mapAppend (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 arg-2 '()) (let ((e-1 (car arg-4))) (let ((e-2 (cdr arg-4))) (PreludeC-45TypesC-45List-mapAppend (cons arg-2 (arg-3 e-1)) arg-3 e-2))))))
(define PreludeC-45TypesC-45List-reverseOnto (lambda (arg-1 arg-2) (if (null? arg-2) arg-1 (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (PreludeC-45TypesC-45List-reverseOnto (cons e-2 arg-1) e-3))))))
(define PreludeC-45TypesC-45List-reverse (lambda (ext-0) (PreludeC-45TypesC-45List-reverseOnto '() ext-0)))
(define Typechecker-n--4385-2633-u--buildRenames (lambda (arg-0 arg-1 arg-2 arg-3) (if (null? arg-3) '() (let ((e-2 (car arg-3))) (let ((e-3 (cdr arg-3))) (let ((e-6 (car e-2))) (cons (cons e-6 arg-2) (Typechecker-n--4385-2633-u--buildRenames arg-0 arg-1 (+ arg-2 1) e-3))))))))
(define Typechecker-checkDecl (lambda (arg-0 arg-1) (case (vector-ref arg-1 0) ((0) (let ((e-0 (vector-ref arg-1 1))) (let ((e-1 (vector-ref arg-1 2))) (vector 1 (vector 0 e-0 (PreludeC-45TypesC-45List-mapAppend '() (lambda (lamc-0) (let ((e-2 (car lamc-0))) (let ((e-3 (cdr lamc-0))) (cons e-2 (Typechecker-convertGammaSyntax e-3))))) e-1)))))) ((1) (vector 0 (vector 0 "Codata declarations not yet supported"))) (else (let ((e-4 (vector-ref arg-1 1))) (let ((e-5 (vector-ref arg-1 2))) (let ((e-6 (vector-ref arg-1 3))) (let ((e-7 (vector-ref arg-1 4))) (let ((u--gammaC-39 (Typechecker-convertGammaSyntax e-5))) (let ((u--renames (cons (PreludeC-45TypesC-45List-lengthTR e-5) (PreludeC-45TypesC-45List-reverse (Typechecker-n--4385-2633-u--buildRenames arg-1 arg-0 0 e-5))))) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-check_prod_type u--renames arg-0 u--gammaC-39 e-7 e-6) (lambda (u--bodyC-39) (vector 1 (vector 2 e-4 u--gammaC-39 e-6 u--bodyC-39))))))))))))))
(define Typechecker-n--4517-2747-u--checkProgramHelper (lambda (arg-0 arg-1 arg-2) (if (null? arg-2) (vector 1 '()) (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-checkDecl arg-1 e-2) (lambda (u--funDecl) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (Typechecker-n--4517-2747-u--checkProgramHelper arg-0 (cons u--funDecl arg-1) e-3) (lambda (u--restDecls) (vector 1 (cons u--funDecl u--restDecls)))))))))))
(define Typechecker-checkProgram (lambda (arg-0) (Typechecker-n--4517-2747-u--checkProgramHelper arg-0 '() arg-0)))
(define Main-case--main-3595 (lambda (arg-0 arg-1) (lambda (clam-0) (case (vector-ref arg-1 0) ((0) (let ((e-2 (vector-ref arg-1 1))) (case (vector-ref e-2 0) ((1) (let ((e-6 (vector-ref e-2 1))) (PreludeC-45IO-prim__putStr (string-append e-6 "\xa;") clam-0)))(else (PreludeC-45IO-prim__putStr "oh no...\xa;" clam-0))))) (else (let ((e-5 (vector-ref arg-1 1))) (let ((sc1 (Typechecker-checkProgram e-5))) (case (vector-ref sc1 0) ((0) (let ((e-2 (vector-ref sc1 1))) (case (vector-ref e-2 0) ((0) (let ((e-6 (vector-ref e-2 1))) (PreludeC-45IO-prim__putStr (string-append e-6 "\xa;") clam-0)))(else (PreludeC-45IO-prim__putStr "ruh roh...\xa;" clam-0))))) (else (PreludeC-45IO-prim__putStr "yay!\xa;" clam-0))))))))))
(define Parser-parse (lambda (arg-1 arg-2) (let ((sc0 (arg-1 (PreludeC-45Types-fastUnpack arg-2)))) (case (vector-ref sc0 0) ((0) (let ((e-2 (vector-ref sc0 1))) (vector 0 e-2))) (else (let ((e-5 (vector-ref sc0 1))) (let ((e-8 (car e-5))) (vector 1 e-8))))))))
(define Parser-eof (lambda (ext-0) (if (null? ext-0) (vector 1 (cons 'erased '())) (let ((e-2 (car ext-0))) (vector 0 (vector 1 (string-append "unexpected " (PreludeC-45Types-fastPack (cons e-2 '())))))))))
(define Parser-C-60C-124C-62 (lambda (arg-1 arg-2 ext-0) (let ((sc0 (arg-1 ext-0))) (case (vector-ref sc0 0) ((0) (arg-2 ext-0)) (else (let ((e-5 (vector-ref sc0 1))) (let ((e-8 (car e-5))) (let ((e-9 (cdr e-5))) (vector 1 (cons e-8 e-9))))))))))
(define Parser-notP (lambda (arg-1 ext-0) (let ((sc0 (arg-1 ext-0))) (case (vector-ref sc0 0) ((0) (vector 1 (cons 'erased ext-0))) (else (let ((e-5 (vector-ref sc0 1))) (if (null? ext-0) (vector 0 (vector 1 "EOF")) (let ((e-2 (car ext-0))) (vector 0 (vector 1 (string-append "unexpected " (PreludeC-45Types-fastPack (cons e-2 '())))))))))))))
(define Parser-case--C-62C-62C-61-1786 (lambda (arg-2 arg-3 arg-4 arg-5) (case (vector-ref arg-5 0) ((0) (let ((e-2 (vector-ref arg-5 1))) (vector 0 e-2))) (else (let ((e-5 (vector-ref arg-5 1))) (let ((e-8 (car e-5))) (let ((e-9 (cdr e-5))) (let ((sc2 ((arg-2 e-8) e-9))) (case (vector-ref sc2 0) ((0) (let ((e-2 (vector-ref sc2 1))) (vector 0 e-2))) (else (let ((e-6 (vector-ref sc2 1))) (let ((e-11 (car e-6))) (let ((e-10 (cdr e-6))) (vector 1 (cons e-11 e-10)))))))))))))))
(define Parser-u--C-62C-62C-61_Monad_Parser (lambda (arg-2 arg-3 ext-0) (Parser-case--C-62C-62C-61-1786 arg-3 arg-2 ext-0 (arg-2 ext-0))))
(define Parser-u--pure_Applicative_Parser (lambda (arg-1 ext-0) (vector 1 (cons arg-1 ext-0))))
(define Parser-sequence_ (lambda (arg-1 ext-0) (if (null? arg-1) (Parser-u--pure_Applicative_Parser 'erased ext-0) (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (Parser-u--C-62C-62C-61_Monad_Parser e-2 (lambda (u--_) (lambda (eta-0) (Parser-sequence_ e-3 eta-0))) ext-0))))))
(define Parser-stringP (lambda (arg-0 ext-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-0) (Parser-sequence_ (PreludeC-45TypesC-45List-mapAppend '() (lambda (eta-1) (lambda (eta-2) (Parser-char eta-1 eta-2))) (PreludeC-45Types-fastUnpack arg-0)) eta-0)) (lambda (u--_) (lambda (eta-0) (Parser-u--pure_Applicative_Parser arg-0 eta-0))) ext-0)))
(define Parser-keyword (lambda (arg-0 ext-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-0) (Parser-stringP arg-0 eta-0)) (lambda (u--_) (lambda (eta-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-1) (Parser-notP csegen-16 eta-1)) (lambda (_-0) (lambda (eta-1) (Parser-u--pure_Applicative_Parser arg-0 eta-1))) eta-0))) ext-0)))
(define PreludeC-45InterfacesC-45BoolC-45Semigroup-u--C-60C-43C-62_Semigroup_AnyBool (lambda (arg-0 arg-1) (cond ((equal? arg-0 1) 1) (else arg-1))))
(define PreludeC-45Types-elemBy (lambda (arg-2 arg-3 arg-4) (let ((e-6 (vector-ref arg-2 5))) ((((e-6 'erased) 'erased) (cons (lambda (arg-8505) (lambda (arg-8508) (PreludeC-45InterfacesC-45BoolC-45Semigroup-u--C-60C-43C-62_Semigroup_AnyBool arg-8505 arg-8508))) 0)) (arg-3 arg-4)))))
(define PreludeC-45Types-elem (lambda (arg-2 arg-3 ext-0) (PreludeC-45Types-elemBy arg-2 (let ((e-1 (car arg-3))) e-1) ext-0)))
(define Parser-err (lambda (arg-1 ext-0) (vector 0 (vector 1 arg-1))))
(define Parser-parseIntType (lambda (ext-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-0) (Parser-keyword "Int" eta-0)) (lambda (u--_) (lambda (eta-0) (Parser-u--pure_Applicative_Parser '() eta-0))) ext-0)))
(define Parser-reserved (cons "let" (cons "in" (cons "Int" (cons "data" (cons "fn" '()))))))
(define Parser-parseUserType (lambda (ext-0) (Parser-u--C-62C-62C-61_Monad_Parser csegen-15 (lambda (u--first) (lambda (eta-0) (Parser-u--C-62C-62C-61_Monad_Parser csegen-17 (lambda (u--rest) (let ((u--name (PreludeC-45Types-fastPack (cons u--first u--rest)))) (lambda (clam-0) (let ((sc0 ((PreludeC-45Types-elem csegen-32 csegen-35 u--name) Parser-reserved))) (cond ((equal? sc0 1) (Parser-err (string-append "Reserved word: " u--name) clam-0)) (else (Parser-u--pure_Applicative_Parser (box u--name) clam-0))))))) eta-0))) ext-0)))
(define Parser-ws0 (lambda (ext-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-0) (Parser-many0 csegen-6 eta-0)) (lambda (u--_) (lambda (eta-0) (Parser-u--pure_Applicative_Parser 'erased eta-0))) ext-0)))
(define Parser-parseType (lambda (ext-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-0) (Parser-ws0 eta-0)) (lambda (u--_) (lambda (eta-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-1) (Parser-C-60C-124C-62 (lambda (eta-2) (Parser-parseIntType eta-2)) (lambda (eta-2) (Parser-parseUserType eta-2)) eta-1)) (lambda (u--t) (lambda (eta-1) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-2) (Parser-ws0 eta-2)) (lambda (_-0) (lambda (eta-2) (Parser-u--pure_Applicative_Parser u--t eta-2))) eta-1))) eta-0))) ext-0)))
(define Parser-parseConstructor (lambda (ext-0) (Parser-u--C-62C-62C-61_Monad_Parser csegen-15 (lambda (u--first) (lambda (eta-0) (Parser-u--C-62C-62C-61_Monad_Parser csegen-17 (lambda (u--rest) (let ((u--name (PreludeC-45Types-fastPack (cons u--first u--rest)))) (lambda (eta-1) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (clam-0) (let ((sc0 ((PreludeC-45Types-elem csegen-32 csegen-35 u--name) Parser-reserved))) (cond ((equal? sc0 1) (Parser-err u--name clam-0)) (else (Parser-u--pure_Applicative_Parser 'erased clam-0))))) (lambda (_-10685) (lambda (eta-2) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-3) (Parser-ws0 eta-3)) (lambda (u--_) (lambda (eta-3) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-4) (Parser-many0 (lambda (eta-5) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-6) (Parser-parseType eta-6)) (lambda (u--t) (lambda (eta-6) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-7) (Parser-ws0 eta-7)) (lambda (_-0) (lambda (eta-7) (Parser-u--pure_Applicative_Parser (cons "" u--t) eta-7))) eta-6))) eta-5)) eta-4)) (lambda (u--types) (lambda (eta-4) (Parser-u--pure_Applicative_Parser (cons u--name u--types) eta-4))) eta-3))) eta-2))) eta-1)))) eta-0))) ext-0)))
(define Parser-ws1 (lambda (ext-0) (let ((sc0 (Parser-many1 csegen-6 ext-0))) (case (vector-ref sc0 0) ((0) (let ((e-2 (vector-ref sc0 1))) (vector 0 e-2))) (else (let ((e-5 (vector-ref sc0 1))) (let ((e-9 (cdr e-5))) (vector 1 (cons 'erased e-9)))))))))
(define Parser-parseDataDecl (lambda (ext-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-0) (Parser-keyword "data" eta-0)) (lambda (u--_) (lambda (eta-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-1) (Parser-ws1 eta-1)) (lambda (_-0) (lambda (eta-1) (Parser-u--C-62C-62C-61_Monad_Parser csegen-15 (lambda (u--first) (lambda (eta-2) (Parser-u--C-62C-62C-61_Monad_Parser csegen-17 (lambda (u--rest) (let ((u--name (PreludeC-45Types-fastPack (cons u--first u--rest)))) (lambda (eta-3) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-4) (Parser-ws0 eta-4)) (lambda (_-1) (lambda (eta-4) (Parser-u--C-62C-62C-61_Monad_Parser csegen-59 (lambda (_-2) (lambda (eta-5) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-6) (Parser-ws0 eta-6)) (lambda (_-3) (lambda (eta-6) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-7) (Parser-parseConstructor eta-7)) (lambda (first-0) (lambda (eta-7) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-8) (Parser-many0 (lambda (eta-9) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-10) (Parser-char #\| eta-10)) (lambda (_-4) (lambda (eta-10) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-11) (Parser-ws0 eta-11)) (lambda (_-5) (lambda (eta-11) (Parser-parseConstructor eta-11))) eta-10))) eta-9)) eta-8)) (lambda (rest-0) (lambda (eta-8) (Parser-u--pure_Applicative_Parser (vector 0 u--name (cons first-0 rest-0)) eta-8))) eta-7))) eta-6))) eta-5))) eta-4))) eta-3)))) eta-2))) eta-1))) eta-0))) ext-0)))
(define Parser-lazyP (lambda (arg-1 ext-0) ((arg-1 'erased) ext-0)))
(define Parser-parens (lambda (arg-1 ext-0) (Parser-u--C-62C-62C-61_Monad_Parser csegen-47 (lambda (u--_) (lambda (eta-0) (Parser-u--C-62C-62C-61_Monad_Parser arg-1 (lambda (u--x) (lambda (eta-1) (Parser-u--C-62C-62C-61_Monad_Parser csegen-49 (lambda (_-0) (lambda (eta-2) (Parser-u--pure_Applicative_Parser u--x eta-2))) eta-1))) eta-0))) ext-0)))
(define Parser-parseCtorApp (lambda (ext-0) (Parser-u--C-62C-62C-61_Monad_Parser csegen-15 (lambda (u--first) (lambda (eta-0) (Parser-u--C-62C-62C-61_Monad_Parser csegen-17 (lambda (u--rest) (let ((u--name (PreludeC-45Types-fastPack (cons u--first u--rest)))) (lambda (eta-1) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-2) (Parser-many0 (lambda (eta-3) (Parser-lazyP (lambda (_-2565) (lambda (eta-4) (Parser-parseExpr eta-4))) eta-3)) eta-2)) (lambda (u--args) (lambda (eta-2) (Parser-u--pure_Applicative_Parser (vector 3 u--name u--args) eta-2))) eta-1)))) eta-0))) ext-0)))
(define Parser-parseIdentName (lambda (ext-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-0) (Parser-satisfy (lambda (eta-1) (PreludeC-45Types-isLower eta-1)) eta-0)) (lambda (u--first) (lambda (eta-0) (Parser-u--C-62C-62C-61_Monad_Parser csegen-17 (lambda (u--rest) (lambda (eta-1) (Parser-u--pure_Applicative_Parser (PreludeC-45Types-fastPack (cons u--first u--rest)) eta-1))) eta-0))) ext-0)))
(define Parser-parseIdent (lambda (ext-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-0) (Parser-parseIdentName eta-0)) (lambda (u--name) (lambda (clam-0) (let ((sc0 ((PreludeC-45Types-elem csegen-32 csegen-35 u--name) Parser-reserved))) (cond ((equal? sc0 1) (Parser-err (string-append "Reserved word: " u--name) clam-0)) (else (Parser-u--pure_Applicative_Parser (vector 1 u--name) clam-0)))))) ext-0)))
(define Parser-parseIntLit (lambda (ext-0) (Parser-u--C-62C-62C-61_Monad_Parser csegen-73 (lambda (u--first) (lambda (eta-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-1) (Parser-many0 csegen-73 eta-1)) (lambda (u--digits) (lambda (eta-1) (Parser-u--pure_Applicative_Parser (vector 0 (cast-string-boundedInt (PreludeC-45Types-fastPack (cons u--first u--digits)) 63)) eta-1))) eta-0))) ext-0)))
(define Parser-parseAtom (lambda (ext-0) (Parser-C-60C-124C-62 (lambda (eta-0) (Parser-parens (lambda (eta-1) (Parser-lazyP (lambda (_-2579) (lambda (eta-2) (Parser-parseExpr eta-2))) eta-1)) eta-0)) (lambda (eta-0) (Parser-C-60C-124C-62 (lambda (eta-1) (Parser-parseCtorApp eta-1)) (lambda (eta-1) (Parser-C-60C-124C-62 (lambda (eta-2) (Parser-parseIntLit eta-2)) (lambda (eta-2) (Parser-parseIdent eta-2)) eta-1)) eta-0)) ext-0)))
(define Parser-perhaps (lambda (arg-1 ext-0) (let ((sc0 (arg-1 ext-0))) (case (vector-ref sc0 0) ((0) (vector 1 (cons '() ext-0))) (else (let ((e-5 (vector-ref sc0 1))) (let ((e-8 (car e-5))) (let ((e-9 (cdr e-5))) (vector 1 (cons (box e-8) e-9))))))))))
(define Parser-parseLet (lambda (ext-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-0) (Parser-keyword "let" eta-0)) (lambda (u--_) (lambda (eta-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-1) (Parser-ws0 eta-1)) (lambda (_-0) (lambda (eta-1) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-2) (Parser-parseIdentName eta-2)) (lambda (u--name) (lambda (eta-2) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-3) (Parser-ws0 eta-3)) (lambda (_-1) (lambda (eta-3) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-4) (Parser-perhaps (lambda (eta-5) (Parser-u--C-62C-62C-61_Monad_Parser csegen-48 (lambda (_-2) (lambda (eta-6) (Parser-parseType eta-6))) eta-5)) eta-4)) (lambda (u--t) (lambda (eta-4) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-5) (Parser-ws0 eta-5)) (lambda (_-2) (lambda (eta-5) (Parser-u--C-62C-62C-61_Monad_Parser csegen-59 (lambda (_-3) (lambda (eta-6) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-7) (Parser-lazyP (lambda (_-2657) (lambda (eta-8) (Parser-parseExpr eta-8))) eta-7)) (lambda (u--val) (lambda (eta-7) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-8) (Parser-keyword "in" eta-8)) (lambda (_-4) (lambda (eta-8) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-9) (Parser-lazyP (lambda (_-2679) (lambda (eta-10) (Parser-parseExpr eta-10))) eta-9)) (lambda (u--body) (lambda (eta-9) (Parser-u--pure_Applicative_Parser (vector 7 u--name u--t u--val u--body) eta-9))) eta-8))) eta-7))) eta-6))) eta-5))) eta-4))) eta-3))) eta-2))) eta-1))) eta-0))) ext-0)))
(define Parser-parseExpr (lambda (ext-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-0) (Parser-ws0 eta-0)) (lambda (u--_) (lambda (eta-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-1) (Parser-C-60C-124C-62 (lambda (eta-2) (Parser-parseLet eta-2)) (lambda (eta-2) (Parser-parseAtom eta-2)) eta-1)) (lambda (u--x) (lambda (eta-1) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-2) (Parser-ws0 eta-2)) (lambda (_-0) (lambda (eta-2) (Parser-u--pure_Applicative_Parser u--x eta-2))) eta-1))) eta-0))) ext-0)))
(define Parser-parseParam (lambda (ext-0) (Parser-u--C-62C-62C-61_Monad_Parser csegen-47 (lambda (u--_) (lambda (eta-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-1) (Parser-ws0 eta-1)) (lambda (_-0) (lambda (eta-1) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-2) (Parser-parseIdentName eta-2)) (lambda (u--name) (lambda (eta-2) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-3) (Parser-ws0 eta-3)) (lambda (_-1) (lambda (eta-3) (Parser-u--C-62C-62C-61_Monad_Parser csegen-48 (lambda (_-2) (lambda (eta-4) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-5) (Parser-parseType eta-5)) (lambda (u--t) (lambda (eta-5) (Parser-u--C-62C-62C-61_Monad_Parser csegen-49 (lambda (_-3) (lambda (eta-6) (Parser-u--pure_Applicative_Parser (cons u--name u--t) eta-6))) eta-5))) eta-4))) eta-3))) eta-2))) eta-1))) eta-0))) ext-0)))
(define Parser-parseFuncDecl (lambda (ext-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-0) (Parser-keyword "fn" eta-0)) (lambda (u--_) (lambda (eta-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-1) (Parser-ws1 eta-1)) (lambda (_-0) (lambda (eta-1) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-2) (Parser-parseIdentName eta-2)) (lambda (u--name) (lambda (eta-2) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-3) (Parser-many0 (lambda (eta-4) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-5) (Parser-ws0 eta-5)) (lambda (_-1) (lambda (eta-5) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-6) (Parser-parseParam eta-6)) (lambda (u--p) (lambda (eta-6) (Parser-u--pure_Applicative_Parser u--p eta-6))) eta-5))) eta-4)) eta-3)) (lambda (u--params) (lambda (eta-3) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-4) (Parser-ws0 eta-4)) (lambda (_-1) (lambda (eta-4) (Parser-u--C-62C-62C-61_Monad_Parser csegen-48 (lambda (_-2) (lambda (eta-5) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-6) (Parser-parseType eta-6)) (lambda (u--retType) (lambda (eta-6) (Parser-u--C-62C-62C-61_Monad_Parser csegen-59 (lambda (_-3) (lambda (eta-7) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-8) (Parser-parseExpr eta-8)) (lambda (u--body) (lambda (eta-8) (Parser-u--pure_Applicative_Parser (vector 2 u--name u--params u--retType u--body) eta-8))) eta-7))) eta-6))) eta-5))) eta-4))) eta-3))) eta-2))) eta-1))) eta-0))) ext-0)))
(define Parser-parseDecl (lambda (ext-0) (Parser-C-60C-124C-62 (lambda (eta-0) (Parser-parseDataDecl eta-0)) (lambda (eta-0) (Parser-parseFuncDecl eta-0)) ext-0)))
(define Parser-parseTop (lambda (ext-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-0) (Parser-ws0 eta-0)) (lambda (u--_) (lambda (eta-0) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-1) (Parser-many0 (lambda (eta-2) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-3) (Parser-parseDecl eta-3)) (lambda (u--d) (lambda (eta-3) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-4) (Parser-ws0 eta-4)) (lambda (_-0) (lambda (eta-4) (Parser-u--pure_Applicative_Parser u--d eta-4))) eta-3))) eta-2)) eta-1)) (lambda (u--decls) (lambda (eta-1) (Parser-u--C-62C-62C-61_Monad_Parser (lambda (eta-2) (Parser-eof eta-2)) (lambda (_-0) (lambda (eta-2) (Parser-u--pure_Applicative_Parser u--decls eta-2))) eta-1))) eta-0))) ext-0)))
(define Main-main (Main-case--main-3595 "data MaybeInt = None | Some Int\xa;fn main (n : Int) : MaybeInt = case Some n of\xa;Some a -> None\xa;None -> Some 3" (Parser-parse (lambda (eta-0) (Parser-parseTop eta-0)) "data MaybeInt = None | Some Int\xa;fn main (n : Int) : MaybeInt = case Some n of\xa;Some a -> None\xa;None -> Some 3")))
(define PreludeC-45EqOrd-u--C-60_Ord_Integer (lambda (arg-0 arg-1) (let ((sc0 (or (and (< arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Integer (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--compare_Ord_Integer (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Integer arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else (let ((sc1 (PreludeC-45EqOrd-u--C-61C-61_Eq_Integer arg-0 arg-1))) (cond ((equal? sc1 1) 1) (else 2))))))))
(define PreludeC-45EqOrd-compareInteger (lambda (ext-0 ext-1) (PreludeC-45EqOrd-u--compare_Ord_Integer ext-0 ext-1)))
(define PrimIO-unsafeCreateWorld (lambda (arg-1) (arg-1 #f)))
(define PrimIO-unsafePerformIO (lambda (arg-1) (PrimIO-unsafeCreateWorld (lambda (u--w) (arg-1 u--w)))))
(collect-request-handler
  (let* ([gc-counter 1]
         [log-radix 2]
         [radix-mask (sub1 (bitwise-arithmetic-shift 1 log-radix))]
         [major-gc-factor 2]
         [trigger-major-gc-allocated (* major-gc-factor (bytes-allocated))])
    (lambda ()
      (cond
        [(>= (bytes-allocated) trigger-major-gc-allocated)
         ;; Force a major collection if memory use has doubled
         (collect (collect-maximum-generation))
         (blodwen-run-finalisers)
         (set! trigger-major-gc-allocated (* major-gc-factor (bytes-allocated)))]
        [else
         ;; Imitate the built-in rule, but without ever going to a major collection
         (let ([this-counter gc-counter])
           (if (> (add1 this-counter)
                  (bitwise-arithmetic-shift-left 1 (* log-radix (sub1 (collect-maximum-generation)))))
               (set! gc-counter 1)
               (set! gc-counter (add1 this-counter)))
           (collect
            ;; Find the minor generation implied by the counter
            (let loop ([c this-counter] [gen 0])
              (cond
                [(zero? (bitwise-and c radix-mask))
                 (loop (bitwise-arithmetic-shift-right c log-radix)
                       (add1 gen))]
                [else
                 gen]))))]))))
(PrimIO-unsafePerformIO Main-main)
  (collect-request-handler (lambda () (collect (collect-maximum-generation)) (blodwen-run-finalisers)))
  (collect-rendezvous)
  
  )